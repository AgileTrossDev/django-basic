# CCSDS Library - Used to package SC commands into TC Codeblocks inside a CLTU
# The heart of this library is using a factory to create CLTU builder to
# construct the CLTU frames.
#
# USAGE:
#
#
# REMINDER: Before check-in manually execute pycodestyle
# > autopep8 --in-place --aggressive --aggressive --recursive .
# > pycodestyle --show-source --show-pep8 ccsds/ccsds.py > scratch/style.txt
#
###############################################################################

# Imports
from ccsds import exceptions
from ccsds import utils
from ccsds import constants
from ccsds import formats


###############################################################################
# Inserts the TC Transfer Frame header in front of the frame_data (Fig. 4.1-12)
#
# Note: Should return bytearray
###############################################################################
def create_tc_transfer_frame(
        scid, vcid, frame_data, by_pass_flag=True,
        cntrl_cmd_flag=False, nesn=0):

    # Check for required fields
    if scid is None:
        raise exceptions.InvalidTransferFrameHeaderVal(
            "transfer_frame: Invalid SCID")

    if vcid is None:
        raise exceptions.InvalidTransferFrameHeaderVal(
            "transfer_frame: Invalid VCID")

    # Also needs to include the frame header of 5 bytes
    frame_data_length = len(frame_data) + 5

    # frame_data needs to be at least 1 byte
    if frame_data_length < 1:
        raise exceptions.InvalidFrameData(
            "create_tc_transfer_frame input error")

    # Validate Frame Length does not exceed
    if not utils.validate_frame_length(frame_data_length):
        raise exceptions.CmdBufferException(
            "Frame data size of {} larger than CCSDS "
            "standard 1024 bytes".format(frame_data_length))

    # construct the Transfer Frame Header
    hdr = (formats.tc_header_format.build(
        dict(
            version=0,
            by_pass_flag=by_pass_flag,
            cntrl_cmd_flag=cntrl_cmd_flag,
            spare_1=0,
            scid=scid,
            vcid=vcid,
            frm_length=frame_data_length - 1,
            nesn=nesn)
    )
    )

    # Pack Frame Together
    result = bytearray(hdr + frame_data)

    return result


###############################################################################
# Ingests a Transfer Frame (Header & Frame Data ) and constructs complete CLTU
# Fig 4.1-12 - CLTU includes Fill Bits, Start/End Sequence, and Parity.
#
# Inputs
#   - tc_transfer_frame - bytearray representing the CCSDS Transfer Layer
#   - block_size  -  Number of bits found in a tc code block
#                    must be 40, 48, 56, or 64 bits
#   - start_seq_precedes_fill - True means that the 0xEB90 start seq precedes a blocksize
#                               chunk of fill, otherwise blocksize fill is before the 0xEB90
#   - even_blocks - when True means that make sure there is an even number of codeblocks
#                   emitted and generate a fill block when it doesn't
###############################################################################
def create_cltu(
        tc_transfer_frame,
        block_size,
        start_seq_precedes_fill,
        even_blocks=False):

    utils.validate_block_size(block_size)

    result = bytearray()

    if start_seq_precedes_fill:
        result.extend(constants.CLTU_START_SEQ)
        result.extend(constants.CLTU_FILL_BYTES)
    else:
        result.extend(constants.CLTU_FILL_BYTES)
        result.extend(constants.CLTU_START_SEQ)

    result.extend(
        generate_tc_codeblocks(
            tc_transfer_frame,
            block_size,
            even_blocks))
    result.extend(constants.CLTU_END_SEQUENCES[block_size])

    return result


###############################################################################
# Creates a bytearray containing the CCSDS Telecommand Packet
#
# apid -
# data -
# secondary_header_data - Defaults to None
# sequence_flag=constants.STANDALONE_PACKET
# sequence_count=0
#
# Reference: CCSDS 203.0-B-1 section 5
#
# Note: Primary packet header is set to 6 Octets, the secondary header is 
#       optional, and the Application Data (including 2nd Header) can be up to
#       65,536 octets
#
# NOTE: 5.2.1.1 All Telecommand Packets Type shall be set to value "1"
#
#
###############################################################################
def create_tc_packet(apid, data,
                     secondary_header_data=None,
                     sequence_flag=constants.STANDALONE_PACKET,
                     sequence_count=0):
    
    if apid is None:
        raise exceptions.CCSDSException("APID is required for TC packet creation")

    if data is None:
        raise exceptions.CCSDSException("Data is required for TC packet creation")
    
    # Combine 2nd Header with Data and then validate Packet Length
    #
    # NOTE: Packet Data length is zero based, so subtract 1.
    #
    
    extra_hdr_flag = False
    if secondary_header_data is not None:
        extra_hdr_flag = True
        data = secondary_header_data + data

    pd_len = len(data)
    utils.validate_packet_data_length(pd_len)
    
    # construct the Packet Header
    hdr = formats.tc_pkt_header_format.build(
        dict(
            version=0,
            type=1,
            sec_hdr_flag=extra_hdr_flag,
            applic_process_id=apid,
            seq_flags=sequence_flag,
            seq_cnt=sequence_count,
            pkt_len=pd_len - 1
        )
    )

    # Packetize the data into a bytearray and return it.    
    return bytearray(hdr + data)


###############################################################################
# Builds a TC Codeblock by adding fill and then inserting parity
#
# NOTE: block_size is in bits
#
###############################################################################
def generate_tc_codeblocks(tc_transfer_frame, block_size, even_blocks=True):
    tc_codeblock_data_blocks = utils.fillpad_and_block(tc_transfer_frame, block_size, even_blocks)
    return utils.add_parity_and_join(tc_codeblock_data_blocks)


###############################################################################
# Main
#
# TODO: Command line arguments to possible ingest a file handle representing
#       the a command and packages a CLTU file and writes it to a file.
###############################################################################
if __name__ == '__main__':
    print("CCSDS Library Command-line execution started")
    print("Not Implemented yet!")
    print("CCSDS Library Command-line execution complete")
