import binascii
import io
import os
import pytest

from construct import BitStruct
from construct import BitsInteger
from construct import Flag
from hamcrest import assert_that, equal_to

from ccsds import bch, exceptions
# Code being tested
from ccsds import ccsds
from ccsds import constants
from ccsds import formats

# Useful Debug Tools:
# ---------------------
# od  -b  <filename>.dat
# hexdump -C <filename>.dat

# Constants used in test
TEST_OUTPUT_DIR = "scratch"
WV04_SAT_CLTU_ID_ = int('0101111000', 2)  # 10 Bits
OUTPUT_RESULTS_TO_FILE = False


def test_create_tc_packet():
    # 000 1 0 00000000000  11 00000000000000  0000000000000000
    # 1000c000xxxx - xxxx: length of payload - 1
    # apid 0, no secondary header, unsegmented
    #
    # 000 1 1 000 0111 1011  10 00000000000000  0000000000000000
    # 187b8000xxxx
    test_cases = {
        'apid0_nosechdr_standalone_seq': {
            'apid': 0,
            'sequence': constants.STANDALONE_PACKET,
            'data': bytearray.fromhex('0102030405'),
            'result': bytearray.fromhex("1000c00000040102030405"),
        },
        'apid123_sechdr_1stpkt': {
            'apid': 123,
            'sequence': constants.FIRST_PACKET,
            'sechdr': bytearray.fromhex('F1F2'),
            'data': bytearray.fromhex('010203'),
            'result': bytearray.fromhex("187b40000004F1F2010203"),
        },
        'apid123_sechdr_contpkt': {
            'apid': 123,
            'sequence': constants.CONTINUING_PACKET,
            'sechdr': bytearray.fromhex('F1F2'),
            'data': bytearray.fromhex('010203'),
            'result': bytearray.fromhex("187b00000004F1F2010203"),
        },
        'apid123_sechdr_lastpkt': {
            'apid': 123,
            'sequence': constants.LAST_PACKET,
            'sechdr': bytearray.fromhex('F1F2'),
            'data': bytearray.fromhex('010203'),
            'result': bytearray.fromhex("187b80000004F1F2010203"),
        },
        'apid123_sechdr_lastpkt_seq123': {
            'apid': 123,
            'sequence': constants.LAST_PACKET,
            'sequence_count': 124,
            'sechdr': bytearray.fromhex('F1F2'),
            'data': bytearray.fromhex('010203'),
            'result': bytearray.fromhex("187b807c0004F1F2010203"),
        }
    }

    for test_name, test_data in test_cases.items():
        result = ccsds.create_tc_packet(test_data['apid'],
                                        test_data['data'],
                                        test_data.get('sechdr', None),
                                        test_data['sequence'],
                                        test_data.get('sequence_count', 0))
        assert_that(result, equal_to(test_data['result']),
                    "Failed on test {} [{}] vs [{}]".format(test_name,
                                                            binascii.hexlify(result),
                                                            binascii.hexlify(test_data['result'])))


def test_tc_packet_create_raises_on_lack_of_apid():
    with pytest.raises(exceptions.CCSDSException):
        ccsds.create_tc_packet(None, None)


def test_tc_packet_create_raises_on_lack_of_data():
    with pytest.raises(exceptions.CCSDSException):
        ccsds.create_tc_packet(0, None)


###############################################################################
# Builds a TC Transfer Frame
###############################################################################
def test_create_tc_transfer_frame():
    test_case = "test_create_tc_transfer_frame"
    #print("\n\nExecuting Test Case: ", test_case)

    # Set Test Data (and experimenting converting from
    # ByteIO->bytes->bytearray)
    buff = io.BytesIO()
    buff.write((0x1111).to_bytes(2, byteorder='big'))
    frame_data = bytearray(buff.getvalue())

    # Frame
    satellite_id = WV04_SAT_CLTU_ID_
    vcid = 0x5
    by_pass_flag = True
    cntrl_cmd_flag = True
    nesn = 3

    # Create the Frame
    frame = ccsds.create_tc_transfer_frame(satellite_id, vcid,
                                           frame_data, by_pass_flag,
                                           cntrl_cmd_flag, nesn)

    # Display/Store Results    
    write_results_to_file(test_case, frame)

    # Validate Results
    assert isinstance(frame, bytearray)

    result_hdr = frame[0:5]
    result_frame_data = frame[5:]
    # print("Result Header:\n", result_hdr)
    # print("Result Frame Data:\n", result_frame_data)

    # Verify the Command Data made it into the Tranfer Frame correctly
    assert result_frame_data == frame_data

    # Check Header
    # construct the Transfer Frame Header
    hdr = (formats.tc_header_format.parse(result_hdr))
    # print("Parsed Result HDR:\n", hdr)
    assert hdr.version == 0
    assert hdr.by_pass_flag == by_pass_flag
    assert hdr.cntrl_cmd_flag == cntrl_cmd_flag
    assert hdr.spare_1 == 0
    assert hdr.scid == satellite_id
    assert hdr.vcid == vcid
    assert hdr.frm_length == 6
    assert hdr.nesn == nesn

    # TODO: Bit bust the header without using the CCSDS to do it?


###############################################################################
# Builds a compelte CLTU, mimicing WV04
###############################################################################
def test_create_cltu():
    test_case = "test_create_cltu"
    #print("\n\nExecuting Test Case: ", test_case)

    # Set Test Data (and experimenting converting from
    # ByteIO->bytes->bytearray)
    buff = io.BytesIO()
    buff.write((0x1111).to_bytes(2, byteorder='big'))
    frame_data = bytearray(buff.getvalue())

    # Frame
    satellite_id = WV04_SAT_CLTU_ID_
    vcid = 0x5
    by_pass_flag = True
    cntrl_cmd_flag = True
    nesn = 3

    # Create the Frame
    #
    # NOTE:  Using library to create test data, low risk
    #
    frame = ccsds.create_tc_transfer_frame(satellite_id, vcid,
                                           frame_data, by_pass_flag,
                                           cntrl_cmd_flag, nesn)
    block_size_bytes = 8
    block_size = block_size_bytes * 8
    start_seq_precedes_fill = False
    cltu = ccsds.create_cltu(frame, block_size, start_seq_precedes_fill)

    # Display/Store Results
    # print("CLTU:\n", cltu)
    write_results_to_file(test_case, cltu)

    # Validate Results
    assert isinstance(frame, bytearray)

    cltu_fill = cltu[0:6]
    cltu_start = cltu[6:8]
    cltu_code_blocks = cltu[8:-8]
    result_hdr = cltu_code_blocks[0:5]
    cltu_end = cltu[-8:]

    assert cltu_fill == constants.CLTU_FILL_BYTES
    assert cltu_start == constants.CLTU_START_SEQ
    assert cltu_end == bytearray.fromhex('C5C5C5C5C5C5C579')

    # construct the Transfer Frame Header
    hdr = (formats.tc_header_format.parse(result_hdr))
    # print("Parsed Result HDR:\n", hdr)
    assert hdr.version == 0
    assert hdr.by_pass_flag == by_pass_flag
    assert hdr.cntrl_cmd_flag == cntrl_cmd_flag
    assert hdr.spare_1 == 0
    assert hdr.scid == satellite_id
    assert hdr.vcid == vcid
    assert hdr.frm_length == 6
    assert hdr.nesn == nesn

    # Check Parity for each blocks
    check_parity_of_data(cltu_code_blocks, block_size_bytes)

###############################################################################
# Test Cases with different size cmd data (odd/even)
###############################################################################

###############################################################################
# Builds a compelte CLTU with 9 Bytes of Data
###############################################################################
def test_create_cltu_with_9_byte_data():
    test_case = "test_create_cltu_with_9_byte_data"
    #print("\n\nExecuting Test Case: ", test_case)

    # Set Test Data (and experimenting converting from
    # ByteIO->bytes->bytearray)
    buff = io.BytesIO()
    buff.write((0x111122223333444455).to_bytes(9, byteorder='big'))
    frame_data = bytearray(buff.getvalue())

    # Frame
    satellite_id = WV04_SAT_CLTU_ID_
    vcid = 0x5
    by_pass_flag = True
    cntrl_cmd_flag = True
    nesn = 3

    # Create the Frame
    #
    # NOTE:  Using library to create test data, low risk
    #
    frame = ccsds.create_tc_transfer_frame(satellite_id, vcid,
                                           frame_data, by_pass_flag,
                                           cntrl_cmd_flag, nesn)
    block_size_bytes = 8
    block_size = block_size_bytes * 8
    start_seq_precedes_fill = False

    #cltu = ccsds.create_cltu(frame, block_size, start_seq_precedes_fill)

    # print("Making call...")
    cltu = ccsds.create_cltu(frame, block_size, start_seq_precedes_fill)
    # print("Exited call")

    # Display/Store Results
    # print("CLTU:\n", cltu)
    write_results_to_file(test_case, cltu)

    # Validate Results
    assert isinstance(frame, bytearray)

    cltu_fill = cltu[0:6]
    cltu_start = cltu[6:8]
    cltu_code_blocks = cltu[8:-8]
    result_hdr = cltu_code_blocks[0:5]
    cltu_end = cltu[-8:]

    assert cltu_fill == constants.CLTU_FILL_BYTES
    assert cltu_start == constants.CLTU_START_SEQ
    assert cltu_end == bytearray.fromhex('C5C5C5C5C5C5C579')

    # construct the Transfer Frame Header
    hdr = (formats.tc_header_format.parse(result_hdr))
    # print("Parsed Result HDR:\n", hdr)
    assert hdr.version == 0
    assert hdr.by_pass_flag == by_pass_flag
    assert hdr.cntrl_cmd_flag == cntrl_cmd_flag
    assert hdr.spare_1 == 0
    assert hdr.scid == satellite_id
    assert hdr.vcid == vcid
    assert hdr.frm_length == len(frame_data) + 5 - 1
    assert hdr.nesn == nesn

    # Check Parity for each blocks
    check_parity_of_data(cltu_code_blocks, block_size_bytes)

######################
#### Test Helpers ####
######################


cltu_start_format = BitStruct(
    "fill" / BitsInteger(48),
    "start" / BitsInteger(16),
    "version" / BitsInteger(2),      # 2 bit
    "by_pass_flag" / Flag,           # 1 BIT
    "cntrl_cmd_flag" / Flag,         # 1 BIT
    "spare_1" / BitsInteger(2),      # 2 BIT
    "scid" / BitsInteger(10),      # 10 bit
    "vcid" / BitsInteger(6),         # 6 Bits,
    "frm_length" / BitsInteger(10),  # 10 Bits
    "nesn" / BitsInteger(8),         # 8 Bits
    "first_tc_data" / BitsInteger(16),
    "parity" / BitsInteger(7),         # 8 Bits
    "p_fill" / BitsInteger(1),         # 1 Bits
)

tc_format = BitStruct(
    "fill" / BitsInteger(56),
    "parity" / BitsInteger(7),         # 8 Bits
    "p_fill" / BitsInteger(1),         # 1 Bits
)

cltu_start_tail = BitStruct(
    "end_seq" / BitsInteger(64),
)


###############################################################################
# Write the data found in result to a file in the output directory
###############################################################################
def write_results_to_file(test_case, result):
    if (OUTPUT_RESULTS_TO_FILE):
        # Create IO Destination
        io_out = open_output_buffer(test_case)
        io_out.write(bytes(result))
        io_out.close()


###############################################################################
# Create IO Destination
###############################################################################
def open_output_buffer(atest_case):
    dest = TEST_OUTPUT_DIR + "/" + atest_case + ".dat"    
    return open(dest, "wb")


###############################################################################
#
###############################################################################
def check_cltu_file(atest_case, cmd_bytes):
    if (OUTPUT_RESULTS_TO_FILE):
        path = TEST_OUTPUT_DIR + "/" + atest_case + ".dat"

        f_handle = open(path, 'rb')
        check_cltu_start(f_handle, cmd_bytes)
        f_handle.close()


###############################################################################
# Check Parity for each block in byte array cltu_code_blocks
###############################################################################
def check_parity_of_data(cltu_code_blocks, block_size_bytes):
    blocks = [cltu_code_blocks[i:i + block_size_bytes]
              for i in range(0, len(cltu_code_blocks), block_size_bytes)]

    # Reconstruct TC Frame with calculated BCH parity for each block
    for block in blocks:
        parity = bch.block_parity(block[:-1])  # note that you do not run parity on the parity byte itself
        assert parity == block[-1]


###############################################################################
#
###############################################################################
def check_cltu_start(f_handle, cmd_bytes):

     # Read start of CLTU and First Code Block
    raw = f_handle.read(16)
    data = cltu_start_format.parse(raw)
    
    assert(data.frm_length + 1) == cmd_bytes
    assert WV04_SAT_CLTU_ID_ == data.scid
    assert data.vcid == 5
    assert data.nesn == 11


###############################################################################
# Helper function to convert bytearrays to integers
###############################################################################
def to_int(val):
    return int.from_bytes(val, byteorder='big', signed=False)


###############################################################################
# Main
###############################################################################
if not os.path.exists(TEST_OUTPUT_DIR):
    # print("Creating test output directory: ", TEST_OUTPUT_DIR)
    os.makedirs(TEST_OUTPUT_DIR)
else:
    pass
    # print("Using test output directory: ", TEST_OUTPUT_DIR)
